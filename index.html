<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Snake</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Prevent scrolling on mobile when touching the game area */
        body {
            overscroll-behavior: none;
            touch-action: none;
        }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        .font-retro {
            font-family: 'Press Start 2P', cursive;
        }
        /* Neon glow effects */
        .neon-text {
            text-shadow: 0 0 5px #4ade80, 0 0 10px #4ade80;
        }
        canvas {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #374151;
        }
        .portal-glow {
            box-shadow: 0 0 15px #ec4899, 0 0 30px #ec4899;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4 font-sans select-none">

    <!-- Game Container -->
    <div class="w-full max-w-md flex flex-col items-center gap-4">
        
        <!-- Header / Score -->
        <div class="w-full flex justify-between items-end px-2">
            <div>
                <h1 class="text-xs text-gray-400 uppercase tracking-widest mb-1">Score</h1>
                <div id="scoreDisplay" class="text-3xl font-retro text-green-400 neon-text">0</div>
            </div>
            <div>
                <h1 class="text-xs text-gray-400 uppercase tracking-widest mb-1 text-center">Level</h1>
                <div id="levelDisplay" class="text-xl font-retro text-yellow-400 text-center">1</div>
            </div>
            <div>
                <h1 class="text-xs text-gray-400 uppercase tracking-widest mb-1 text-right">High Score</h1>
                <div id="highScoreDisplay" class="text-xl font-retro text-gray-500 text-right">0</div>
            </div>
        </div>

        <!-- Game Canvas Wrapper -->
        <div class="relative w-full aspect-square bg-gray-800 rounded-lg overflow-hidden border-4 border-gray-700 shadow-2xl">
            <canvas id="gameCanvas" class="w-full h-full block cursor-pointer outline-none" tabindex="0"></canvas>
            
            <!-- Start/Game Over Overlay -->
            <div id="overlay" class="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-10 transition-opacity duration-300">
                <h2 id="overlayTitle" class="text-4xl font-retro text-yellow-400 mb-6 text-center leading-relaxed">SNAKE</h2>
                <p id="overlaySubtitle" class="text-gray-300 mb-8 text-center text-sm px-4">Swipe or use Arrow Keys to move</p>
                <button id="actionButton" class="px-8 py-3 bg-green-500 hover:bg-green-600 text-black font-bold font-retro rounded shadow-[0_4px_0_rgb(21,128,61)] active:shadow-[0_0px_0_rgb(21,128,61)] active:translate-y-[4px] transition-all">
                    PLAY
                </button>
            </div>
            
            <!-- Level Up Notification -->
            <div id="levelUpMsg" class="absolute inset-0 flex items-center justify-center pointer-events-none opacity-0 transition-opacity duration-500">
                <h2 class="text-4xl font-retro text-pink-500 text-center stroke-black" style="-webkit-text-stroke: 2px black;">LEVEL 2</h2>
            </div>
        </div>

        <!-- Controls Hint -->
        <div class="flex justify-between w-full text-xs text-gray-500 mt-2">
            <span>PC: Arrow Keys / WASD</span>
            <span>Mobile: Swipe</span>
        </div>
        
        <!-- On-screen D-Pad for easier mobile play (optional but helpful fallback) -->
        <div class="grid grid-cols-3 gap-2 mt-4 md:hidden">
            <div></div>
            <button id="btnUp" class="w-14 h-14 bg-gray-700 rounded-full flex items-center justify-center active:bg-gray-600 shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg>
            </button>
            <div></div>
            <button id="btnLeft" class="w-14 h-14 bg-gray-700 rounded-full flex items-center justify-center active:bg-gray-600 shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
            </button>
            <button id="btnDown" class="w-14 h-14 bg-gray-700 rounded-full flex items-center justify-center active:bg-gray-600 shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </button>
            <button id="btnRight" class="w-14 h-14 bg-gray-700 rounded-full flex items-center justify-center active:bg-gray-600 shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
            </button>
        </div>

    </div>

    <script>
        // --- Game Constants & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlaySubtitle = document.getElementById('overlaySubtitle');
        const actionButton = document.getElementById('actionButton');
        const levelUpMsg = document.getElementById('levelUpMsg');

        // Grid settings
        const TILE_COUNT = 20; // 20x20 grid
        let TILE_SIZE = 20; // Will be calculated dynamically

        // Game State
        let level = 1;
        let snake = [];
        let foods = []; // Array to support multiple foods
        let velocity = { x: 0, y: 0 };
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameLoopId;
        let isGameRunning = false;
        let lastRenderTime = 0;
        const SNAKE_SPEED = 5.33; // 1.5x slower

        // Monster State
        let monsters = []; // Array to support multiple monsters
        let monsterMoveTick = 0;
        const MONSTER_MOVE_THRESHOLD = 3; 
        
        // Portal State
        let portal = null; // {x, y} or null

        // Damage Cooldown (invulnerability frames after hit in lvl 2)
        let damageCooldown = 0;

        // Particles for sparkling trail
        let particles = [];

        // Input buffer
        let inputQueue = [];

        // Initial Setup
        highScoreDisplay.textContent = highScore;
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // --- Core Game Functions ---

        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = container.clientWidth;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            ctx.scale(dpr, dpr);
            TILE_SIZE = size / TILE_COUNT;
            
            if (!isGameRunning) draw(); 
        }

        function initGame() {
            // Start at Level 1
            level = 1;
            levelDisplay.textContent = level;
            
            resetBoardForLevel();
            
            score = 0;
            scoreDisplay.textContent = score;
            
            isGameRunning = true;
            overlay.classList.add('opacity-0', 'pointer-events-none');
            
            lastRenderTime = 0;
            window.requestAnimationFrame(gameLoop);
            canvas.focus();
        }

        function resetBoardForLevel() {
            // Reset Snake
            const startX = 10;
            const startY = 10;
            snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY },
                { x: startX - 3, y: startY },
                { x: startX - 4, y: startY }
            ];
            
            velocity = { x: 1, y: 0 };
            inputQueue = [];
            particles = [];
            foods = [];
            monsters = [];
            portal = null;
            monsterMoveTick = 0;
            damageCooldown = 0;

            if (level === 1) {
                spawnFood();
                spawnMonster(1); // 1 monster
            } else if (level === 2) {
                // Spawn 3 foods
                for(let i=0; i<3; i++) spawnFood();
                // Spawn 2 monsters
                spawnMonster(2);
            }
        }

        function startLevel2() {
            level = 2;
            levelDisplay.textContent = level;
            
            // Show Level Up Message
            levelUpMsg.classList.remove('opacity-0');
            setTimeout(() => {
                levelUpMsg.classList.add('opacity-0');
            }, 1500);

            resetBoardForLevel();
        }

        function spawnFood() {
            let validPosition = false;
            let newFood = {};
            while (!validPosition) {
                newFood = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };
                
                // Check collision with snake
                const onSnake = snake.some(s => s.x === newFood.x && s.y === newFood.y);
                // Check collision with existing food
                const onFood = foods.some(f => f.x === newFood.x && f.y === newFood.y);
                // Check collision with portal
                const onPortal = portal && (portal.x === newFood.x && portal.y === newFood.y);

                validPosition = !onSnake && !onFood && !onPortal;
            }
            foods.push(newFood);
        }

        function spawnPortal() {
            let validPosition = false;
            while (!validPosition) {
                portal = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };
                const onSnake = snake.some(s => s.x === portal.x && s.y === portal.y);
                const onFood = foods.some(f => f.x === portal.x && f.y === portal.y);
                
                validPosition = !onSnake && !onFood;
            }
        }

        function spawnMonster(count) {
            for (let i = 0; i < count; i++) {
                let validPosition = false;
                let newMonster = {};
                while (!validPosition) {
                    newMonster = {
                        x: Math.floor(Math.random() * TILE_COUNT),
                        y: Math.floor(Math.random() * TILE_COUNT)
                    };
                    
                    const head = snake[0];
                    const dist = Math.abs(newMonster.x - head.x) + Math.abs(newMonster.y - head.y);
                    const onBody = snake.some(s => s.x === newMonster.x && s.y === newMonster.y);
                    const onOtherMonster = monsters.some(m => m.x === newMonster.x && m.y === newMonster.y);

                    if (dist > 8 && !onBody && !onOtherMonster) {
                        validPosition = true;
                    }
                }
                monsters.push(newMonster);
            }
        }

        function gameLoop(currentTime) {
            if (!isGameRunning) return;
            window.requestAnimationFrame(gameLoop);

            updateParticles();
            draw(); 

            const secondsSinceLastRender = (currentTime - lastRenderTime) / 1000;
            if (secondsSinceLastRender < 1 / SNAKE_SPEED) return;

            lastRenderTime = currentTime;
            update();
        }

        function createSparkle() {
            if (snake.length === 0) return;
            const tail = snake[snake.length - 1];
            const x = (tail.x * TILE_SIZE) + (Math.random() * TILE_SIZE);
            const y = (tail.y * TILE_SIZE) + (Math.random() * TILE_SIZE);
            
            particles.push({
                x: x, y: y, size: Math.random() * 3 + 1,
                alpha: 1, life: 1.0
            });
        }

        function updateParticles() {
            if (Math.random() > 0.5) createSparkle(); 
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.life -= 0.02; p.y -= 0.5;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function update() {
            // Damage Cooldown Tick
            if (damageCooldown > 0) damageCooldown--;

            // Input Processing
            if (inputQueue.length > 0) {
                const nextDir = inputQueue.shift();
                if ((nextDir.x !== 0 && velocity.x === 0) || 
                    (nextDir.y !== 0 && velocity.y === 0)) {
                    velocity = nextDir;
                }
            }

            const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

            // 1. Wall Collision (Always Fatal)
            if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                gameOver();
                return;
            }

            // 2. Self Collision
            // Level 1: Fatal. Level 2: Ignored (based on user request)
            if (level === 1) {
                if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    gameOver();
                    return;
                }
            }

            // Move Snake
            snake.unshift(head);

            // 3. Food Collision
            const eatenFoodIndex = foods.findIndex(f => f.x === head.x && f.y === head.y);
            if (eatenFoodIndex !== -1) {
                score++;
                scoreDisplay.textContent = score;
                foods.splice(eatenFoodIndex, 1); // Remove eaten food
                spawnFood(); // Spawn new one

                // Level 1 Portal Spawn Logic
                if (level === 1 && score >= 3 && !portal) {
                    spawnPortal();
                }
            } else {
                snake.pop();
            }

            // 4. Portal Collision (Level 1 only)
            if (portal && head.x === portal.x && head.y === portal.y) {
                startLevel2();
                return; // Stop update for this frame
            }

            // 5. Monster Logic
            
            // Check Collision BEFORE Move
            checkMonsterCollisions(head);
            if (!isGameRunning) return; // Check if died in collision

            monsterMoveTick++;
            if (monsterMoveTick >= MONSTER_MOVE_THRESHOLD) {
                monsterMoveTick = 0;
                monsters.forEach(m => moveSingleMonster(m));
                
                // Check Collision AFTER Move
                // Re-calculate head in case snake moved? No, snake moves once per update.
                // We use current head position.
                checkMonsterCollisions(head);
            }
        }

        function checkMonsterCollisions(head) {
            if (damageCooldown > 0) return; // Invulnerable

            const hitMonster = monsters.some(m => m.x === head.x && m.y === head.y);
            
            if (hitMonster) {
                if (level === 1) {
                    gameOver();
                } else if (level === 2) {
                    // Shrink snake
                    if (snake.length > 1) {
                        snake.pop(); // Remove tail
                        damageCooldown = 10; // Frames of invulnerability
                        // Visual feedback handled in draw
                    }
                    // Note: In Level 2, game doesn't end on monster touch, just shrinks.
                    // If snake is size 1, it stays size 1.
                }
            }
        }

        function moveSingleMonster(m) {
            const head = snake[0];
            const dx = head.x - m.x;
            const dy = head.y - m.y;
            if (Math.abs(dx) > Math.abs(dy)) m.x += Math.sign(dx);
            else if (dy !== 0) m.y += Math.sign(dy);
        }

        function draw() {
            // Background
            ctx.fillStyle = '#1f2937'; 
            ctx.fillRect(0, 0, TILE_COUNT * TILE_SIZE, TILE_COUNT * TILE_SIZE);

            // Grid
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= TILE_COUNT; i++) {
                ctx.beginPath(); ctx.moveTo(i * TILE_SIZE, 0); ctx.lineTo(i * TILE_SIZE, TILE_COUNT * TILE_SIZE); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i * TILE_SIZE); ctx.lineTo(TILE_COUNT * TILE_SIZE, i * TILE_SIZE); ctx.stroke();
            }

            // Portal (Level 1 only)
            if (portal) {
                ctx.fillStyle = '#ec4899'; // pink-500
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ec4899';
                ctx.beginPath();
                ctx.arc((portal.x * TILE_SIZE) + (TILE_SIZE/2), (portal.y * TILE_SIZE) + (TILE_SIZE/2), TILE_SIZE/1.5, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
                // Inner swirl
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc((portal.x * TILE_SIZE) + (TILE_SIZE/2), (portal.y * TILE_SIZE) + (TILE_SIZE/2), TILE_SIZE/3, 0, Math.PI*2);
                ctx.fill();
            }

            // Monster(s)
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ffffff';
            monsters.forEach(m => {
                ctx.beginPath();
                // Draw slightly smaller to help with "barely touching" complaints
                ctx.arc((m.x * TILE_SIZE) + (TILE_SIZE/2), (m.y * TILE_SIZE) + (TILE_SIZE/2), TILE_SIZE/2.2, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Sparkles
            ctx.fillStyle = '#fbbf24';
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // Food(s)
            ctx.fillStyle = '#f97316'; // orange
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#f97316';
            foods.forEach(f => {
                ctx.beginPath();
                ctx.arc((f.x * TILE_SIZE) + (TILE_SIZE/2), (f.y * TILE_SIZE) + (TILE_SIZE/2), TILE_SIZE/2.5, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Snake
            // Blink effect if taking damage in Lvl 2
            if (damageCooldown > 0 && damageCooldown % 2 === 0) {
                ctx.fillStyle = '#ef4444'; // Flash red
            } else {
                ctx.fillStyle = '#22c55e';
            }
            
            snake.forEach((segment, index) => {
                if (damageCooldown === 0) {
                   if (index === 0) {
                        ctx.fillStyle = '#4ade80'; 
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#4ade80';
                    } else {
                        ctx.fillStyle = '#22c55e';
                        ctx.shadowBlur = 0;
                    } 
                }
                const padding = 1; 
                ctx.fillRect(segment.x * TILE_SIZE + padding, segment.y * TILE_SIZE + padding, TILE_SIZE - 2, TILE_SIZE - 2);
            });
            ctx.shadowBlur = 0;
        }

        function gameOver() {
            isGameRunning = false;
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreDisplay.textContent = highScore;
                overlaySubtitle.textContent = `New High Score! ${score}`;
            } else {
                overlaySubtitle.textContent = `Game Over! Score: ${score}`;
            }

            overlayTitle.textContent = "GAME OVER";
            actionButton.textContent = "TRY AGAIN";
            overlay.classList.remove('opacity-0', 'pointer-events-none');
        }

        // --- Input Handling ---
        document.addEventListener('keydown', (e) => {
            const key = e.key;
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(key) > -1) e.preventDefault();
            if (!isGameRunning) return;
            const desiredDirection = { x: 0, y: 0 };
            if (key === 'ArrowUp' || key === 'w' || key === 'W') desiredDirection.y = -1;
            else if (key === 'ArrowDown' || key === 's' || key === 'S') desiredDirection.y = 1;
            else if (key === 'ArrowLeft' || key === 'a' || key === 'A') desiredDirection.x = -1;
            else if (key === 'ArrowRight' || key === 'd' || key === 'D') desiredDirection.x = 1;
            else return;
            inputQueue.push(desiredDirection);
            if(inputQueue.length > 2) inputQueue.shift();
        });

        const handleBtnClick = (dx, dy) => {
            if (!isGameRunning) return;
            inputQueue.push({x: dx, y: dy});
            if(inputQueue.length > 2) inputQueue.shift();
        };

        // Mobile Controls
        document.getElementById('btnUp').addEventListener('touchstart', (e) => { e.preventDefault(); handleBtnClick(0, -1); });
        document.getElementById('btnDown').addEventListener('touchstart', (e) => { e.preventDefault(); handleBtnClick(0, 1); });
        document.getElementById('btnLeft').addEventListener('touchstart', (e) => { e.preventDefault(); handleBtnClick(-1, 0); });
        document.getElementById('btnRight').addEventListener('touchstart', (e) => { e.preventDefault(); handleBtnClick(1, 0); });
        document.getElementById('btnUp').addEventListener('mousedown', (e) => { handleBtnClick(0, -1); });
        document.getElementById('btnDown').addEventListener('mousedown', (e) => { handleBtnClick(0, 1); });
        document.getElementById('btnLeft').addEventListener('mousedown', (e) => { handleBtnClick(-1, 0); });
        document.getElementById('btnRight').addEventListener('mousedown', (e) => { handleBtnClick(1, 0); });

        let touchStartX = 0;
        let touchStartY = 0;
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
        canvas.addEventListener('touchend', (e) => {
            if (!isGameRunning) return;
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) return;
            const desiredDirection = { x: 0, y: 0 };
            if (Math.abs(dx) > Math.abs(dy)) desiredDirection.x = dx > 0 ? 1 : -1;
            else desiredDirection.y = dy > 0 ? 1 : -1;
            inputQueue.push(desiredDirection);
            if(inputQueue.length > 2) inputQueue.shift();
        }, { passive: false });

        actionButton.addEventListener('click', initGame);
    </script>
</body>
</html>

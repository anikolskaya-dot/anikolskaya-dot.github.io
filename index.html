<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Snake</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Prevent scrolling on mobile when touching the game area */
        body {
            overscroll-behavior: none;
            touch-action: none;
        }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        .font-retro {
            font-family: 'Press Start 2P', cursive;
        }
        /* Neon glow effects */
        .neon-text {
            text-shadow: 0 0 5px #4ade80, 0 0 10px #4ade80;
        }
        canvas {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #374151;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4 font-sans select-none">

    <!-- Game Container -->
    <div class="w-full max-w-md flex flex-col items-center gap-4">
        
        <!-- Header / Score -->
        <div class="w-full flex justify-between items-end px-2">
            <div>
                <h1 class="text-xs text-gray-400 uppercase tracking-widest mb-1">Score</h1>
                <div id="scoreDisplay" class="text-3xl font-retro text-green-400 neon-text">0</div>
            </div>
            <div>
                <h1 class="text-xs text-gray-400 uppercase tracking-widest mb-1 text-right">High Score</h1>
                <div id="highScoreDisplay" class="text-xl font-retro text-gray-500 text-right">0</div>
            </div>
        </div>

        <!-- Game Canvas Wrapper -->
        <div class="relative w-full aspect-square bg-gray-800 rounded-lg overflow-hidden border-4 border-gray-700 shadow-2xl">
            <canvas id="gameCanvas" class="w-full h-full block cursor-pointer outline-none" tabindex="0"></canvas>
            
            <!-- Start/Game Over Overlay -->
            <div id="overlay" class="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-10 transition-opacity duration-300">
                <h2 id="overlayTitle" class="text-4xl font-retro text-yellow-400 mb-6 text-center leading-relaxed">SNAKE</h2>
                <p id="overlaySubtitle" class="text-gray-300 mb-8 text-center text-sm px-4">Swipe or use Arrow Keys to move</p>
                <button id="actionButton" class="px-8 py-3 bg-green-500 hover:bg-green-600 text-black font-bold font-retro rounded shadow-[0_4px_0_rgb(21,128,61)] active:shadow-[0_0px_0_rgb(21,128,61)] active:translate-y-[4px] transition-all">
                    PLAY
                </button>
            </div>
        </div>

        <!-- Controls Hint -->
        <div class="flex justify-between w-full text-xs text-gray-500 mt-2">
            <span>PC: Arrow Keys / WASD</span>
            <span>Mobile: Swipe</span>
        </div>
        
        <!-- On-screen D-Pad for easier mobile play (optional but helpful fallback) -->
        <div class="grid grid-cols-3 gap-2 mt-4 md:hidden">
            <div></div>
            <button id="btnUp" class="w-14 h-14 bg-gray-700 rounded-full flex items-center justify-center active:bg-gray-600 shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg>
            </button>
            <div></div>
            <button id="btnLeft" class="w-14 h-14 bg-gray-700 rounded-full flex items-center justify-center active:bg-gray-600 shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
            </button>
            <button id="btnDown" class="w-14 h-14 bg-gray-700 rounded-full flex items-center justify-center active:bg-gray-600 shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </button>
            <button id="btnRight" class="w-14 h-14 bg-gray-700 rounded-full flex items-center justify-center active:bg-gray-600 shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
            </button>
        </div>

    </div>

    <script>
        // --- Game Constants & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlaySubtitle = document.getElementById('overlaySubtitle');
        const actionButton = document.getElementById('actionButton');

        // Grid settings
        const TILE_COUNT = 20; // 20x20 grid
        let TILE_SIZE = 20; // Will be calculated dynamically

        // Game State
        let snake = [];
        let food = { x: 15, y: 15 };
        let velocity = { x: 0, y: 0 };
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameLoopId;
        let isGameRunning = false;
        let lastRenderTime = 0;
        const SNAKE_SPEED = 5.33; // Decreased speed (8 / 1.5)

        // Monster State
        let monster = { x: 0, y: 0 };
        let monsterMoveTick = 0;
        const MONSTER_MOVE_THRESHOLD = 3; // Monster moves once every 3 snake moves

        // Particles for sparkling trail
        let particles = [];

        // Input buffer to prevent double turns in one frame
        let inputQueue = [];

        // Initial Setup
        highScoreDisplay.textContent = highScore;
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // --- Core Game Functions ---

        function resizeCanvas() {
            // Get the container width
            const container = canvas.parentElement;
            const size = container.clientWidth;
            
            // Set canvas resolution (high dpi support)
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            
            // Scale context for CSS pixels
            ctx.scale(dpr, dpr);
            
            // Calculate tile size
            TILE_SIZE = size / TILE_COUNT;
            
            if (!isGameRunning) {
                draw(); // Redraw static state if resizing while paused/stopped
            }
        }

        function initGame() {
            // Reset Snake: Start with 5 units, centered
            const startX = 10;
            const startY = 10;
            snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY },
                { x: startX - 3, y: startY },
                { x: startX - 4, y: startY }
            ];
            
            velocity = { x: 1, y: 0 }; // Start moving right
            inputQueue = [];
            particles = []; // Clear particles
            score = 0;
            scoreDisplay.textContent = score;
            spawnFood();
            spawnMonster(); // Spawn the hunter
            
            monsterMoveTick = 0; // Reset monster timer

            isGameRunning = true;
            overlay.classList.add('opacity-0', 'pointer-events-none');
            
            lastRenderTime = 0;
            window.requestAnimationFrame(gameLoop);
            
            // Focus canvas for immediate keyboard control without clicking
            canvas.focus();
        }

        function spawnFood() {
            let validPosition = false;
            while (!validPosition) {
                food = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };
                
                // Make sure food doesn't spawn on snake body
                validPosition = !snake.some(segment => segment.x === food.x && segment.y === food.y);
            }
        }

        function spawnMonster() {
            let validPosition = false;
            while (!validPosition) {
                monster = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };
                
                // Ensure monster spawns at least 8 tiles away from snake head
                const head = snake[0];
                const dist = Math.abs(monster.x - head.x) + Math.abs(monster.y - head.y);
                
                // Also ensure it doesn't spawn on top of the snake body immediately
                const onBody = snake.some(s => s.x === monster.x && s.y === monster.y);

                if (dist > 8 && !onBody) {
                    validPosition = true;
                }
            }
        }

        function gameLoop(currentTime) {
            if (!isGameRunning) return;

            window.requestAnimationFrame(gameLoop);

            // Update particles every frame for smooth animation
            updateParticles();
            
            // Re-draw every frame to animate particles even if snake hasn't moved
            draw(); 

            const secondsSinceLastRender = (currentTime - lastRenderTime) / 1000;
            if (secondsSinceLastRender < 1 / SNAKE_SPEED) return;

            lastRenderTime = currentTime;
            update();
            // draw() is called above every frame
        }

        function createSparkle() {
            if (snake.length === 0) return;
            const tail = snake[snake.length - 1];
            
            // Add a particle at the tail position
            // Randomize position slightly within the tile
            const x = (tail.x * TILE_SIZE) + (Math.random() * TILE_SIZE);
            const y = (tail.y * TILE_SIZE) + (Math.random() * TILE_SIZE);
            
            particles.push({
                x: x,
                y: y,
                size: Math.random() * 3 + 1,
                alpha: 1,
                life: 1.0 // 100% life
            });
        }

        function updateParticles() {
            // Add new sparkle at current tail position
            if (Math.random() > 0.5) createSparkle(); // 50% chance per frame to sparkle

            // Update existing particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.life -= 0.02; // Fade out speed
                p.y -= 0.5; // Float up slightly
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function update() {
            // Process Input
            if (inputQueue.length > 0) {
                const nextDir = inputQueue.shift();
                // Prevent 180 degree turns
                if ((nextDir.x !== 0 && velocity.x === 0) || 
                    (nextDir.y !== 0 && velocity.y === 0)) {
                    velocity = nextDir;
                }
            }

            // Calculate new head position
            const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

            // 1. Wall Collision Check
            if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                gameOver();
                return;
            }

            // 2. Self Collision Check
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            // Move Snake (Add new head)
            snake.unshift(head);

            // 3. Food Collision Check
            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreDisplay.textContent = score;
                // Don't pop the tail, so snake grows by 1
                spawnFood();
            } else {
                // Remove tail if no food eaten
                snake.pop();
            }

            // 4. Monster Logic
            // Check collision BEFORE moving monster (did snake run into monster?)
            if (head.x === monster.x && head.y === monster.y) {
                gameOver();
                return;
            }

            monsterMoveTick++;
            if (monsterMoveTick >= MONSTER_MOVE_THRESHOLD) {
                monsterMoveTick = 0;
                moveMonster();
                
                // Check collision AFTER moving monster (did monster catch snake?)
                if (monster.x === head.x && monster.y === head.y) {
                    gameOver();
                    return;
                }
            }
        }

        function moveMonster() {
            const head = snake[0];
            const dx = head.x - monster.x;
            const dy = head.y - monster.y;

            // Simple chase logic: move 1 step closer on the axis with larger distance
            if (Math.abs(dx) > Math.abs(dy)) {
                monster.x += Math.sign(dx);
            } else if (dy !== 0) {
                monster.y += Math.sign(dy);
            }
        }

        function draw() {
            // Clear Canvas
            ctx.fillStyle = '#1f2937'; // gray-800
            ctx.fillRect(0, 0, TILE_COUNT * TILE_SIZE, TILE_COUNT * TILE_SIZE);

            // Draw Grid (Optional, makes it look techy)
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= TILE_COUNT; i++) {
                ctx.beginPath();
                ctx.moveTo(i * TILE_SIZE, 0);
                ctx.lineTo(i * TILE_SIZE, TILE_COUNT * TILE_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * TILE_SIZE);
                ctx.lineTo(TILE_COUNT * TILE_SIZE, i * TILE_SIZE);
                ctx.stroke();
            }

            // Draw Monster (Big White Point)
            ctx.fillStyle = '#ffffff'; // white
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ffffff';
            ctx.beginPath();
            // Draw it slightly larger than food
            ctx.arc(
                (monster.x * TILE_SIZE) + (TILE_SIZE / 2),
                (monster.y * TILE_SIZE) + (TILE_SIZE / 2),
                TILE_SIZE / 1.8, 
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 0; // Reset shadow

            // Draw Sparkles (The Line Following the Snake)
            ctx.fillStyle = '#fbbf24'; // amber-400 (goldish)
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // Draw Food (Orange Point)
            ctx.fillStyle = '#f97316'; // orange-500
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#f97316';
            ctx.beginPath();
            ctx.arc(
                (food.x * TILE_SIZE) + (TILE_SIZE / 2),
                (food.y * TILE_SIZE) + (TILE_SIZE / 2),
                TILE_SIZE / 2.5,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 0; // Reset shadow

            // Draw Snake
            snake.forEach((segment, index) => {
                // Head is brighter
                if (index === 0) {
                    ctx.fillStyle = '#4ade80'; // green-400
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#4ade80';
                } else {
                    ctx.fillStyle = '#22c55e'; // green-500
                    ctx.shadowBlur = 0;
                }

                // slightly smaller than tile for segmented look
                const padding = 1; 
                ctx.fillRect(
                    segment.x * TILE_SIZE + padding, 
                    segment.y * TILE_SIZE + padding, 
                    TILE_SIZE - (padding * 2), 
                    TILE_SIZE - (padding * 2)
                );
            });
            ctx.shadowBlur = 0;
        }

        function gameOver() {
            isGameRunning = false;
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreDisplay.textContent = highScore;
                overlaySubtitle.textContent = `New High Score! ${score}`;
            } else {
                overlaySubtitle.textContent = `Game Over! Score: ${score}`;
            }

            overlayTitle.textContent = "GAME OVER";
            actionButton.textContent = "TRY AGAIN";
            
            overlay.classList.remove('opacity-0', 'pointer-events-none');
        }

        // --- Input Handling ---

        // 1. Keyboard Controls
        document.addEventListener('keydown', (e) => {
            const key = e.key;
            // Prevent scrolling with arrows
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(key) > -1) {
                e.preventDefault();
            }

            if (!isGameRunning) return;

            const desiredDirection = { x: 0, y: 0 };

            if (key === 'ArrowUp' || key === 'w' || key === 'W') desiredDirection.y = -1;
            else if (key === 'ArrowDown' || key === 's' || key === 'S') desiredDirection.y = 1;
            else if (key === 'ArrowLeft' || key === 'a' || key === 'A') desiredDirection.x = -1;
            else if (key === 'ArrowRight' || key === 'd' || key === 'D') desiredDirection.x = 1;
            else return;

            // Add to queue (allows quick key presses without missing turns)
            inputQueue.push(desiredDirection);
            // Limit queue size to prevent massive input lag buildup
            if(inputQueue.length > 2) inputQueue.shift();
        });

        // 2. Button Controls (On-screen)
        const handleBtnClick = (dx, dy) => {
            if (!isGameRunning) return;
            inputQueue.push({x: dx, y: dy});
            if(inputQueue.length > 2) inputQueue.shift();
        };

        document.getElementById('btnUp').addEventListener('touchstart', (e) => { e.preventDefault(); handleBtnClick(0, -1); });
        document.getElementById('btnDown').addEventListener('touchstart', (e) => { e.preventDefault(); handleBtnClick(0, 1); });
        document.getElementById('btnLeft').addEventListener('touchstart', (e) => { e.preventDefault(); handleBtnClick(-1, 0); });
        document.getElementById('btnRight').addEventListener('touchstart', (e) => { e.preventDefault(); handleBtnClick(1, 0); });
        // Mouse support for buttons too
        document.getElementById('btnUp').addEventListener('mousedown', (e) => { handleBtnClick(0, -1); });
        document.getElementById('btnDown').addEventListener('mousedown', (e) => { handleBtnClick(0, 1); });
        document.getElementById('btnLeft').addEventListener('mousedown', (e) => { handleBtnClick(-1, 0); });
        document.getElementById('btnRight').addEventListener('mousedown', (e) => { handleBtnClick(1, 0); });


        // 3. Swipe Controls
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling while swiping on canvas
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (!isGameRunning) return;

            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            // Minimum swipe distance to register (Lowered for better sensitivity)
            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) return;

            const desiredDirection = { x: 0, y: 0 };

            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal
                desiredDirection.x = dx > 0 ? 1 : -1;
            } else {
                // Vertical
                desiredDirection.y = dy > 0 ? 1 : -1;
            }

            inputQueue.push(desiredDirection);
            if(inputQueue.length > 2) inputQueue.shift();
        }, { passive: false });


        // Start Button
        actionButton.addEventListener('click', initGame);

    </script>
</body>
</html>

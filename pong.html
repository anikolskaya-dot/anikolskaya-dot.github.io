<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PONG: VOID TENNIS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            touch-action: none;
            color: #fff;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #000;
            border-left: 1px solid #333;
            border-right: 1px solid #333;
        }

        /* UI Оверлеи */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            text-align: center;
        }

        .overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Скример */
        #scaryScreen {
            background: #fff; 
            color: #000;
            z-index: 20; 
        }

        h1 {
            font-size: 60px;
            margin-bottom: 20px;
            font-weight: normal;
            letter-spacing: -2px;
            text-transform: uppercase;
        }

        p {
            font-size: 16px;
            margin-bottom: 40px;
            max-width: 600px;
            line-height: 1.8;
            color: #888;
        }

        /* Кнопки */
        .btn-group {
            display: flex;
            gap: 20px;
        }

        button {
            padding: 15px 40px;
            font-size: 16px;
            background: #000;
            color: #fff;
            border: 1px solid #fff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        button:hover {
            background: #fff;
            color: #000;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            pointer-events: none;
            z-index: 5;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #timerBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 150px;
            color: #111; 
            font-weight: bold;
            pointer-events: none;
            z-index: 1;
        }

        /* Анимация мигания для скримера */
        .glitch-anim {
            animation: glitch 0.2s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-5px, 5px); }
            40% { transform: translate(-5px, -5px); }
            60% { transform: translate(5px, 5px); }
            80% { transform: translate(5px, -5px); }
            100% { transform: translate(0); }
        }
    </style>
</head>
<body>

    <div id="hud">
        ROUND <span id="roundDisplay">1</span> // 
        COMBO <span id="comboDisplay">0</span>
    </div>

    <div id="timerBox">30</div>

    <!-- Главное меню -->
    <div id="startScreen" class="overlay active">
        <h1>PONG_VOID</h1>
        <p>
            Удерживай мяч.<br>
            2 попадания = Мульти-мяч.<br>
            <b>Чёрная Точка</b> = СМЕРТЬ.<br>
            <b style="color: #ff00ff">Розовая Точка</b> = ???
        </p>
        <div class="btn-group">
            <button onclick="window.startGame(1)">EASY</button>
            <button onclick="window.startGame(2)">MEDIUM</button>
            <button onclick="window.startGame(3)">HARD</button>
        </div>
    </div>

    <!-- Экран проигрыша -->
    <div id="gameOverScreen" class="overlay">
        <h1>FAILURE</h1>
        <p>Сигнал потерян.</p>
        <button id="btnRestart">RETRY</button>
    </div>

    <!-- Экран победы -->
    <div id="nextRoundScreen" class="overlay">
        <h1>SYNCED</h1>
        <p>Переход на следующий уровень.</p>
        <button id="btnNext">PROCEED</button>
    </div>

    <!-- Скример -->
    <div id="scaryScreen" class="overlay">
        <h1 class="glitch-anim" style="font-size: 100px;">VOID</h1>
        <h2 style="margin-top:20px;">DON'T TOUCH IT</h2>
        <button onclick="location.reload()" style="margin-top:50px; border-color: black; background: white; color: black;">WAKE UP</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
    (function() {
        // --- ПЕРЕМЕННЫЕ ---
        let canvas, ctx;
        let timerDisplay, roundDisplay, comboDisplay;
        let startScreen, gameOverScreen, nextRoundScreen, scaryScreen;
        
        let gameRunning = false;
        let animationId;
        let timerInterval;
        
        let round = 1;
        let timeLeft = 30;
        let difficulty = 2;
        let aiBaseSpeed = 3; 
        let aiSpeed = 3;
        
        let enemyMisses = 0;
        let enemyMood = 'normal'; 
        let playerHitStreak = 0;

        // Аномалия (Черная)
        const anomaly = {
            active: false,
            x: 0,
            y: 0,
            radius: 20,
            spawnTime: 0,
            angle: 0
        };

        // Бонус (Розовая)
        const pinkDot = {
            active: false,
            x: 0,
            y: 0,
            radius: 15
        };

        // Режим ЦВЕТА
        let colorfulMode = {
            active: false,
            endTime: 0
        };

        let gameWidth = 800; 
        let gameHeight = 600;
        let balls = [];

        const paddleUser = { x: 0, y: 0, width: 120, height: 30, color: '#fff' };
        const paddleAI = { x: 0, y: 0, width: 120, height: 60, color: '#fff' };
        
        const targetZone = { x: 0, y: 0, width: 0, height: 0 };

        // --- ИНИЦИАЛИЗАЦИЯ ---
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            timerDisplay = document.getElementById('timerBox');
            roundDisplay = document.getElementById('roundDisplay');
            comboDisplay = document.getElementById('comboDisplay');
            
            startScreen = document.getElementById('startScreen');
            gameOverScreen = document.getElementById('gameOverScreen');
            nextRoundScreen = document.getElementById('nextRoundScreen');
            scaryScreen = document.getElementById('scaryScreen');
            
            document.getElementById('btnRestart').onclick = restartGame;
            document.getElementById('btnNext').onclick = nextRound;

            window.startGame = function(level) {
                difficulty = level;
                if (level === 1) aiBaseSpeed = 3;
                if (level === 2) aiBaseSpeed = 5;
                if (level === 3) aiBaseSpeed = 8;
                round = 1;
                aiSpeed = aiBaseSpeed;
                startGameLogic();
            };

            if (canvas && canvas.getContext) {
                ctx = canvas.getContext('2d');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                window.addEventListener('resize', resize);
                resize();
                loop();
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initGame);
        } else {
            initGame();
        }

        function resize() {
            if (!canvas) return;
            gameWidth = window.innerWidth;
            gameHeight = window.innerHeight;
            canvas.width = gameWidth;
            canvas.height = gameHeight;

            paddleUser.y = gameHeight - 50;
            paddleAI.y = 20;

            targetZone.width = gameWidth * 0.9; 
            targetZone.height = (gameHeight / 2) - 10;
            targetZone.x = (gameWidth - targetZone.width) / 2;
            targetZone.y = 0;

            if (!gameRunning) resetSingleBall();
        }

        function createBall(x, y, speedMult = 1) {
            let baseSpeed = 4;
            if (difficulty === 2) baseSpeed = 5;
            if (difficulty === 3) baseSpeed = 7;
            let speed = (baseSpeed + (round * 0.3)) * speedMult;

            return {
                x: x, y: y, radius: 8, speed: speed,
                dx: (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 2 + 1),
                dy: Math.abs(speed),
                active: true
            };
        }

        function resetSingleBall() {
            balls = [];
            balls.push(createBall(gameWidth / 2, gameHeight / 2));
        }

        function spawnMultiball() {
            enemyMood = 'shocked';
            setTimeout(() => { if(enemyMood === 'shocked') enemyMood = 'normal'; }, 1000);
            for(let i=0; i<3; i++) {
                let offX = (Math.random() - 0.5) * 50;
                balls.push(createBall(gameWidth/2 + offX, gameHeight/2, 0.9));
            }
        }

        function startGameLogic() { startRound(); }

        function restartGame() {
            startScreen.classList.remove('active');
            round = 1;
            aiSpeed = aiBaseSpeed;
            startRound();
        }

        function nextRound() {
            round++;
            aiSpeed += 1.5; 
            startRound();
        }

        function startRound() {
            startScreen.classList.remove('active');
            gameOverScreen.classList.remove('active');
            nextRoundScreen.classList.remove('active');
            
            timeLeft = 30;
            enemyMisses = 0;
            enemyMood = 'normal';
            playerHitStreak = 0;
            anomaly.active = false;
            pinkDot.active = false;
            colorfulMode.active = false;
            anomaly.spawnTime = Date.now() + 5000;

            updateHUD();
            resetSingleBall();
            
            paddleUser.x = (gameWidth - paddleUser.width) / 2;
            paddleAI.x = (gameWidth - paddleAI.width) / 2;

            gameRunning = true;
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!gameRunning) return;
                timeLeft--;
                updateHUD();
                if (timeLeft <= 0) onRoundWin();
            }, 1000);
        }

        function updateHUD() {
            if(timerDisplay) timerDisplay.innerText = timeLeft;
            if(roundDisplay) roundDisplay.innerText = round;
            if(comboDisplay) comboDisplay.innerText = playerHitStreak;
        }

        function onGameOver(reason) {
            gameRunning = false;
            clearInterval(timerInterval);
            enemyMood = 'laughing'; 
            draw();
            if (gameOverScreen) gameOverScreen.classList.add('active');
        }

        function onRoundWin() {
            gameRunning = false;
            clearInterval(timerInterval);
            enemyMood = 'crying'; 
            draw();
            if (nextRoundScreen) nextRoundScreen.classList.add('active');
        }

        function triggerJumpscare() {
            gameRunning = false;
            clearInterval(timerInterval);
            if (scaryScreen) scaryScreen.classList.add('active');
            if (navigator.vibrate) navigator.vibrate(500);
        }

        function activateColorfulMode() {
            colorfulMode.active = true;
            colorfulMode.endTime = Date.now() + 5000; // 5 секунд
        }

        function onMouseMove(e) { if (gameRunning && canvas) movePaddle(e.clientX); }
        function onTouchMove(e) { if (gameRunning && canvas && e.touches.length > 0) { e.preventDefault(); movePaddle(e.touches[0].clientX); } }
        
        function movePaddle(clientX) {
            let relativeX = clientX - canvas.offsetLeft;
            let newX = relativeX - paddleUser.width / 2;
            if (newX < 0) newX = 0;
            if (newX + paddleUser.width > gameWidth) newX = gameWidth - paddleUser.width;
            paddleUser.x = newX;
        }

        function updateObjects() {
            const now = Date.now();
            anomaly.angle += 0.05;

            // Таймер цвета
            if (colorfulMode.active && now > colorfulMode.endTime) {
                colorfulMode.active = false;
            }
            
            // Спавн точек
            if (!anomaly.active) {
                if (now > anomaly.spawnTime) {
                    // Спавним черную
                    anomaly.active = true;
                    anomaly.spawnTime = now + 10000;
                    anomaly.x = Math.random() * (gameWidth - 100) + 50;
                    anomaly.y = Math.random() * (gameHeight / 2.5) + 50; 

                    // Спавним розовую одновременно (в другом месте)
                    pinkDot.active = true;
                    pinkDot.x = Math.random() * (gameWidth - 100) + 50;
                    pinkDot.y = Math.random() * (gameHeight / 2.5) + 50;

                    // Если точки заспавнились слишком близко, двигаем розовую
                    let dist = Math.sqrt(Math.pow(anomaly.x - pinkDot.x, 2) + Math.pow(anomaly.y - pinkDot.y, 2));
                    if (dist < 100) {
                        pinkDot.x = (pinkDot.x + 200) % gameWidth;
                    }
                }
            }
        }

        function update() {
            if (!gameRunning) return;

            updateObjects();

            if (balls.length === 0) {
                onGameOver();
                return;
            }

            // AI Logic
            let targetBall = null;
            let minDist = Infinity;
            for (let b of balls) {
                if (b.dy < 0 || b.y < gameHeight/2) {
                    let dist = Math.abs(b.y - paddleAI.y);
                    if (dist < minDist) { minDist = dist; targetBall = b; }
                }
            }
            if (targetBall) {
                let aiCenter = paddleAI.x + paddleAI.width / 2;
                let reactionError = difficulty === 1 ? 50 : 0;
                let targetX = targetBall.x + (Math.random() * reactionError - reactionError/2);
                if (aiCenter < targetX - 10) paddleAI.x += aiSpeed;
                else if (aiCenter > targetX + 10) paddleAI.x -= aiSpeed;
            }
            if (paddleAI.x < 0) paddleAI.x = 0;
            if (paddleAI.x + paddleAI.width > gameWidth) paddleAI.x = gameWidth - paddleAI.width;

            // Physics
            for (let i = balls.length - 1; i >= 0; i--) {
                let b = balls[i];
                b.x += b.dx;
                b.y += b.dy;

                if (b.x - b.radius < 0 || b.x + b.radius > gameWidth) b.dx = -b.dx;

                // Hit Anomaly (Black)
                if (anomaly.active) {
                    let dx = b.x - anomaly.x;
                    let dy = b.y - anomaly.y;
                    if (Math.sqrt(dx*dx + dy*dy) < b.radius + anomaly.radius) {
                        triggerJumpscare();
                        return;
                    }
                }

                // Hit Pink Dot
                if (pinkDot.active) {
                    let dx = b.x - pinkDot.x;
                    let dy = b.y - pinkDot.y;
                    if (Math.sqrt(dx*dx + dy*dy) < b.radius + pinkDot.radius) {
                        activateColorfulMode();
                        pinkDot.active = false; // Точка исчезает после сбора
                    }
                }

                // Out Zone (Top)
                if (b.y < gameHeight / 2) {
                    if (b.x < targetZone.x - b.radius || b.x > targetZone.x + targetZone.width + b.radius) {
                        if (b.dy < 0) { balls.splice(i, 1); continue; }
                    }
                }

                // Lost (Bottom)
                if (b.y - b.radius > gameHeight) { balls.splice(i, 1); continue; }

                // Enemy Miss (Top)
                if (b.y + b.radius < 0) {
                    enemyMisses++;
                    if (enemyMisses >= 3) enemyMood = 'angry';
                    b.y = 50; b.dy = Math.abs(b.speed); b.dx = (Math.random() - 0.5) * 5;
                }

                // Paddle Collision
                if (b.y + b.radius > paddleUser.y && b.y - b.radius < paddleUser.y + paddleUser.height &&
                    b.x > paddleUser.x && b.x < paddleUser.x + paddleUser.width) {
                    b.dy = -Math.abs(b.speed);
                    b.dx = (b.x - (paddleUser.x + paddleUser.width / 2)) * 0.25;
                    playerHitStreak++;
                    updateHUD();
                    if (playerHitStreak % 2 === 0 && balls.length < 12) spawnMultiball();
                }

                if (b.y - b.radius < paddleAI.y + paddleAI.height && b.y + b.radius > paddleAI.y &&
                    b.x > paddleAI.x && b.x < paddleAI.x + paddleAI.width) {
                    b.dy = Math.abs(b.speed);
                }
            }
        }

        // --- DRAW UTILS ---
        function getThemeColor(defaultColor) {
            if (colorfulMode.active) {
                return `hsl(${Math.random() * 360}, 100%, 50%)`;
            }
            return defaultColor;
        }

        function getBgColor() {
            if (colorfulMode.active) {
                // В режиме цвета фон немного светлее (очень темно серый), чтобы цвета выделялись, 
                // или случайный темный оттенок
                return `hsl(${Math.random() * 360}, 50%, 10%)`; 
            }
            return '#000';
        }

        function drawRacket(x, y, w, h, isAI) {
            let color = getThemeColor("#fff");
            
            // Ручка
            ctx.fillStyle = color;
            let handleW = 10;
            let handleH = 30;
            let handleX = x + w/2 - handleW/2;
            let handleY = isAI ? y - handleH : y + h;
            ctx.fillRect(handleX, handleY, handleW, handleH);

            // Обод
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Струны
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=x+10; i<x+w; i+=15) { if(i > x && i < x+w) { ctx.moveTo(i, y); ctx.lineTo(i, y+h); } }
            for(let i=y+10; i<y+h; i+=15) { if(i > y && i < y+h) { ctx.moveTo(x, i); ctx.lineTo(x+w, i); } }
            ctx.stroke();
        }

        function drawHumanisticFace(x, y, w, h, mood) {
            let cx = x + w / 2;
            let cy = y + h / 2;
            let color = getThemeColor("#fff");
            let faceBg = colorfulMode.active ? getThemeColor("#000") : "#000";

            ctx.fillStyle = faceBg; 
            ctx.beginPath(); ctx.ellipse(cx, cy, 30, 25, 0, 0, Math.PI*2); ctx.fill();

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            if (mood === 'angry') {
                ctx.beginPath();
                ctx.moveTo(cx-20, cy-10); ctx.lineTo(cx-5, cy-5);
                ctx.moveTo(cx+20, cy-10); ctx.lineTo(cx+5, cy-5);
                ctx.stroke();
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.arc(cx-12, cy, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx+12, cy, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx, cy+15, 10, Math.PI, 0); ctx.stroke();
            } else if (mood === 'shocked') {
                ctx.beginPath(); ctx.arc(cx-12, cy-10, 5, Math.PI, 0); ctx.stroke();
                ctx.arc(cx+12, cy-10, 5, Math.PI, 0); ctx.stroke();
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.arc(cx-12, cy, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx+12, cy, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(cx, cy+12, 5, 8, 0, 0, Math.PI*2); ctx.stroke();
            } else if (mood === 'laughing') {
                ctx.beginPath(); ctx.moveTo(cx-20, cy); ctx.lineTo(cx-12, cy-5); ctx.lineTo(cx-5, cy);
                ctx.moveTo(cx+5, cy); ctx.lineTo(cx+12, cy-5); ctx.lineTo(cx+20, cy); ctx.stroke();
                ctx.beginPath(); ctx.arc(cx, cy+5, 12, 0, Math.PI, false); ctx.stroke();
            } else if (mood === 'crying') {
                ctx.beginPath(); ctx.moveTo(cx-20, cy-5); ctx.lineTo(cx-5, cy-5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx+5, cy-5); ctx.lineTo(cx+20, cy-5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx-12, cy); ctx.lineTo(cx-12, cy+15); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx+12, cy); ctx.lineTo(cx+12, cy+15); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx-10, cy+15); ctx.bezierCurveTo(cx-5, cy+10, cx+5, cy+20, cx+10, cy+15); ctx.stroke();
            } else {
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.arc(cx-12, cy-2, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx+12, cy-2, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(cx-8, cy+12); ctx.lineTo(cx+8, cy+12); ctx.stroke();
            }
        }

        function draw() {
            if (!ctx) return;
            
            ctx.fillStyle = getBgColor();
            ctx.fillRect(0, 0, gameWidth, gameHeight);

            let mainColor = getThemeColor("#fff");
            let dimmedColor = getThemeColor("#333");
            let zoneColor = getThemeColor("#444");

            // Линия центра
            ctx.strokeStyle = dimmedColor;
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, gameHeight/2); ctx.lineTo(gameWidth, gameHeight/2); ctx.stroke();

            // Зона
            ctx.strokeStyle = zoneColor;
            let zx = targetZone.x; let zw = targetZone.width;
            ctx.beginPath(); ctx.moveTo(zx, 0); ctx.lineTo(zx, 20); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(zx + zw, 0); ctx.lineTo(zx + zw, 20); ctx.stroke();
            
            ctx.fillStyle = colorfulMode.active ? getThemeColor("#fff") : "#1a1a1a";
            ctx.font = "bold 40px Courier New";
            ctx.fillText("X", zx / 2, 40);
            ctx.fillText("X", zx + zw + (gameWidth - (zx + zw))/2, 40);

            // Ракетки
            drawRacket(paddleUser.x, paddleUser.y, paddleUser.width, paddleUser.height, false);
            drawRacket(paddleAI.x, paddleAI.y, paddleAI.width, paddleAI.height, true);
            
            // Лицо
            drawHumanisticFace(paddleAI.x, paddleAI.y, paddleAI.width, paddleAI.height, enemyMood);

            // Аномалия (Черная)
            if (anomaly.active) {
                ctx.save();
                ctx.translate(anomaly.x, anomaly.y);
                ctx.rotate(anomaly.angle);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.arc(0, 0, anomaly.radius + 5, 0, Math.PI * 2); ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();

                ctx.fillStyle = "#000";
                ctx.beginPath(); ctx.arc(anomaly.x, anomaly.y, anomaly.radius, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(anomaly.x, anomaly.y, anomaly.radius, 0, Math.PI * 2); ctx.stroke();
            }

            // Бонус (Розовая)
            if (pinkDot.active) {
                // Если режим уже цветной, розовая точка меняет цвет
                let dotColor = colorfulMode.active ? getThemeColor("#ff00ff") : "#ff00ff";
                ctx.fillStyle = dotColor;
                ctx.beginPath(); ctx.arc(pinkDot.x, pinkDot.y, pinkDot.radius, 0, Math.PI * 2); ctx.fill();
                
                // Пульсация
                ctx.strokeStyle = dotColor;
                ctx.lineWidth = 1;
                ctx.beginPath(); 
                ctx.arc(pinkDot.x, pinkDot.y, pinkDot.radius + Math.sin(Date.now()/200)*3 + 3, 0, Math.PI * 2); 
                ctx.stroke();
            }

            // Мячи
            ctx.fillStyle = mainColor;
            for (let b of balls) {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function loop() {
            try {
                update();
                draw();
                animationId = requestAnimationFrame(loop);
            } catch (err) {
                console.error("Loop failed", err);
                gameRunning = false;
            }
        }
    })();
    </script>
</body>
</html>
